# Inception プロジェクト - 技術選定の理由と根拠

## 目次
1. [プロジェクト概要](#プロジェクト概要)
2. [コンテナ化技術](#コンテナ化技術)
3. [ベースイメージ](#ベースイメージ)
4. [各サービスの技術選定](#各サービスの技術選定)
5. [ネットワーク・ボリューム設計](#ネットワークボリューム設計)
6. [セキュリティ対策](#セキュリティ対策)

## プロジェクト概要

Inceptionプロジェクトは、Dockerを使用した小規模インフラストラクチャの構築を通じて、システム管理の知識を深めることを目的としています。

## コンテナ化技術

### Docker & Docker Compose を選択した理由

#### なぜコンテナ化？
1. **環境の一貫性**: 開発環境と本番環境の差異を最小化
2. **リソース効率**: VMと比較して軽量で高速な起動
3. **スケーラビリティ**: 必要に応じてサービスを個別にスケール可能
4. **ポータビリティ**: どこでも同じ環境を再現可能

#### なぜDocker Compose？
```yaml
# docker-compose.ymlの利点を示す例
services:
  nginx:
    depends_on:
      - wordpress  # 依存関係の明確な定義
    networks:
      - inception-network  # サービス間通信の簡潔な設定
```

**選択理由：**
- **宣言的設定**: YAMLファイルでインフラ全体を定義
- **依存関係管理**: サービスの起動順序を自動制御
- **開発効率**: 単一コマンドで全サービスを管理
- **可読性**: インフラ構成が一目で理解可能

## ベースイメージ

### Alpine Linux 3.18 を選択した理由

```dockerfile
FROM alpine:3.18  # 5MB以下の超軽量イメージ
```

**選択理由：**

1. **セキュリティ**
   - 最小限のパッケージ = 攻撃対象領域の削減
   - musl libcによるメモリ安全性の向上
   - 定期的なセキュリティアップデート

2. **パフォーマンス**
   - イメージサイズ: Alpine(~5MB) vs Debian(~120MB)
   - 起動時間: 数秒での起動が可能
   - メモリ使用量: 最小限のフットプリント

3. **パッケージ管理**
   ```bash
   apk add --no-cache nginx  # キャッシュを残さないクリーンなインストール
   ```

## 各サービスの技術選定

### 1. NGINX - Webサーバー/リバースプロキシ

```nginx
# TLS設定の例
ssl_protocols TLSv1.2 TLSv1.3;  # 最新の安全なプロトコルのみ
ssl_ciphers HIGH:!aNULL:!MD5;   # 強力な暗号化スイート
```

**選択理由：**
- **高性能**: イベント駆動型アーキテクチャで大量の同時接続を処理
- **リバースプロキシ**: PHP-FPMとの効率的な連携
- **SSL/TLS対応**: モダンな暗号化プロトコルのネイティブサポート
- **設定の柔軟性**: 詳細なチューニングが可能

**なぜApacheではなくNGINX？**
- メモリ使用量が少ない（Apache: プロセスベース vs NGINX: イベント駆動）
- 静的コンテンツ配信が高速
- 設定ファイルがシンプルで理解しやすい

### 2. MariaDB - データベース

```sql
-- MariaDBの利点を示す設定例
CREATE DATABASE wordpress_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
-- utf8mb4: 完全なUnicode対応（絵文字も保存可能）
```

**選択理由：**
- **MySQL互換性**: WordPressとの完全な互換性
- **オープンソース**: MySQLのフォークで、より活発な開発
- **パフォーマンス**: クエリ最適化の改善
- **機能拡張**: JSON型、仮想列などの先進機能

**なぜPostgreSQLではなくMariaDB？**
- WordPressのネイティブサポート（追加プラグイン不要）
- MySQLエコシステムとの互換性
- 学習曲線が緩やか

### 3. WordPress + PHP-FPM

```php
// PHP-FPM設定の利点
listen = 9000  // TCPソケットで柔軟な接続
pm = dynamic   // 動的なプロセス管理で効率化
```

**PHP-FPMを選択した理由：**
- **プロセス分離**: Webサーバーとアプリケーションの分離
- **パフォーマンス**: FastCGIプロトコルによる高速化
- **リソース管理**: プロセスプールの細かい制御
- **セキュリティ**: 各プロセスの独立性

**なぜmod_phpではなくPHP-FPM？**
- NGINXとの相性が良い
- メモリ使用量の最適化
- プロセスのリサイクルによる安定性

### 4. WordPress - CMS

**選択理由：**
- **実績**: 世界で最も使用されているCMS
- **拡張性**: 豊富なプラグインエコシステム
- **学習目的**: 実際のプロダクション環境でよく使用される

## ネットワーク・ボリューム設計

### Dockerネットワーク

```yaml
networks:
  inception-network:
    driver: bridge  # 仮想ブリッジネットワーク
```

**Bridge Driverを選択した理由：**
- **分離性**: ホストネットワークから独立
- **セキュリティ**: サービス間の通信を制限可能
- **DNS解決**: サービス名での内部通信
- **ポートマッピング**: 必要なポートのみ公開

### Dockerボリューム

```yaml
volumes:
  wp-volume:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /home/uchida/data/wordpress
```

**Bind Mountを選択した理由：**
- **永続性**: コンテナ削除後もデータが保持
- **バックアップ**: ホストから直接アクセス可能
- **パフォーマンス**: ネイティブファイルシステムの速度
- **デバッグ**: ホストから直接ファイルを確認可能

## セキュリティ対策

### 1. TLS/SSL設定

```nginx
ssl_protocols TLSv1.2 TLSv1.3;  # 古いプロトコルを無効化
```

**理由：**
- **暗号化通信**: すべてのトラフィックを暗号化
- **MITM攻撃防止**: 中間者攻撃からの保護
- **信頼性**: 自己署名証明書でも基本的な暗号化を提供

### 2. 環境変数の使用

```bash
# .envファイルでの機密情報管理
MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
```

**理由：**
- **分離**: コードと設定の分離
- **セキュリティ**: Dockerfileにパスワードを直接記載しない
- **柔軟性**: 環境ごとに異なる設定が可能

### 3. 最小権限の原則

```dockerfile
# 非rootユーザーでの実行
USER nobody:nobody
```

**理由：**
- **権限制限**: 必要最小限の権限で実行
- **攻撃面の削減**: コンテナ侵害時の影響を限定

### 4. ネットワーク分離

```yaml
# 内部ネットワークのみ使用
networks:
  - inception-network  # 外部からの直接アクセスを防止
```

**理由：**
- **アクセス制御**: NGINXのみが外部公開
- **サービス間通信**: 内部DNSによる安全な通信

## パフォーマンス最適化

### 1. マルチステージビルド（将来の改善案）

```dockerfile
# 例: ビルドステージと実行ステージの分離
FROM alpine:3.18 as builder
# ビルド処理
FROM alpine:3.18
COPY --from=builder /app /app
```

**利点：**
- イメージサイズの削減
- ビルドツールを本番環境から除外

### 2. キャッシュ戦略

```dockerfile
RUN apk add --no-cache nginx  # APKキャッシュを残さない
```

**理由：**
- イメージサイズの最小化
- セキュリティ向上（不要なファイルを残さない）

## 監視とロギング

### 現在の実装

```bash
docker compose logs -f  # リアルタイムログ監視
```

### 将来の改善案

- **Prometheus**: メトリクス収集
- **Grafana**: 可視化
- **ELK Stack**: ログ集約と分析

## まとめ

各技術選定は以下の原則に基づいています：

1. **シンプルさ**: 複雑さを避け、理解しやすい構成
2. **セキュリティ**: デフォルトで安全な設定
3. **パフォーマンス**: リソース効率の最大化
4. **保守性**: 長期的な運用を考慮
5. **学習価値**: 実際の現場で使用される技術

これらの技術選定により、小規模ながら本番環境に近い、安全で効率的なインフラストラクチャを構築できます。